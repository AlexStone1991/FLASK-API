# Освоение Peewee ORM: Руководство для начинающих на примере SQLite

Peewee ORM (Object-Relational Mapper) представляет собой простую, компактную и выразительную библиотеку для Python, предназначенную для взаимодействия с различными базами данных. Ее минималистичный дизайн и интуитивно понятный синтаксис делают Peewee отличным выбором для небольших приложений, скриптов и проектов, где требуется функциональность базы данных без излишней сложности. Данное руководство нацелено на разработчиков, знакомых с основами SQL и SQLite, и ставит своей задачей предоставить исчерпывающие учебные материалы для начала работы с Peewee, выполнения CRUD-операций (Create, Read, Update, Delete) и построения запросов с объединением таблиц (JOIN).

## 1. Введение в Peewee ORM

Peewee позволяет разработчикам взаимодействовать с базой данных, используя объекты Python вместо написания SQL-запросов напрямую. Это упрощает разработку, повышает читаемость кода и снижает вероятность ошибок, связанных с синтаксисом SQL.

**Основные компоненты Peewee :**

- **`Database`**: Управляет соединением с базой данных. Peewee поддерживает SQLite, PostgreSQL и MySQL. В данном руководстве мы сосредоточимся на SQLite, так как он встроен в Python и не требует отдельной настройки сервера.
- **`Model`**: Базовый класс для определения таблиц базы данных. Каждая модель в Peewee представляет собой таблицу, а атрибуты модели – столбцы этой таблицы.
- **`Field`**: Классы полей, которые определяют типы столбцов в таблицах (например, текст, целое число, дата) и их ограничения (например, уникальность, возможность быть NULL).
- **`Query`**: Предоставляет методы для извлечения и изменения данных в базе данных.

Peewee автоматически преобразует типы данных Python в соответствующие типы данных, используемые базой данных, и обратно, что позволяет разработчикам работать с привычными типами Python в своем коде.2

## 2. Настройка проекта с Peewee

Настройка проекта с Peewee включает несколько шагов: установку библиотеки, определение соединения с базой данных и создание базовой модели.

Шаг 1: Установка Peewee

Установка Peewee выполняется с помощью pip:

Bash

```
pip install peewee
```

Эта команда устанавливает Peewee без дополнительных зависимостей.

Шаг 2: Определение соединения с базой данных

Сначала необходимо создать экземпляр класса Database. Для SQLite это SqliteDatabase. Рекомендуется выносить определение объекта базы данных в отдельный файл, например, database.py.

Python

```
# database.py
from peewee import SqliteDatabase

# Инициализация SQLite базы данных.
# Файл базы данных будет создан автоматически, если он не существует.
db = SqliteDatabase('library.db')
```

Если файл `library.db` не существует, SQLite автоматически создаст его при первом обращении.

Шаг 3: Создание базовой модели (BaseModel)

Хорошей практикой является создание базового класса модели, который связывает все последующие модели с экземпляром базы данных. Это избавляет от необходимости указывать базу данных для каждой модели отдельно.1 Конфигурация модели хранится во вложенном классе Meta.

Python

```
# models.py
from peewee import Model
from database import db # Импортируем наш объект db

class BaseModel(Model):
    class Meta:
        database = db # Все модели, наследующие BaseModel, будут использовать эту БД
```

Шаг 4: Определение моделей данных

Модели определяются как классы, наследующие BaseModel. Атрибуты класса, являющиеся экземплярами классов полей (например, CharField, IntegerField), представляют собой столбцы таблицы.1

Python

```
# models.py (продолжение)
from peewee import CharField, IntegerField, DateField, FloatField # и другие типы полей

class Book(BaseModel):
    title = CharField(max_length=255, null=False) # Текстовое поле, не может быть пустым
    author = CharField(max_length=100)
    publication_date = DateField(null=True) # Поле даты, может быть пустым
    pages = IntegerField(default=0) # Целочисленное поле, значение по умолчанию 0
    price = FloatField(null=True)

# Другие модели могут быть определены аналогично
```

Peewee автоматически выводит имя таблицы из имени класса (например, класс `Book` будет соответствовать таблице `book`). Это поведение можно переопределить, указав атрибут `table_name` во вложенном классе `Meta` модели.2 Если первичный ключ не определен явно, Peewee автоматически добавляет автоинкрементное целочисленное поле с именем `id`.3

Шаг 5: Создание таблиц в базе данных

После определения моделей необходимо создать соответствующие таблицы в базе данных. Это делается с помощью метода create_tables() объекта Database.

Python

```
# create_tables.py
from database import db
from models import Book # Импортируем все модели, для которых нужно создать таблицы

def create_db_tables():
    db.connect(reuse_if_open=True) # Устанавливаем соединение
    # Peewee проверит существование таблиц перед их созданием
    db.create_tables() # Передаем список классов моделей
    print("Database tables created!")
    db.close() # Закрываем соединение

if __name__ == '__main__':
    create_db_tables()
```

Запуск скрипта `python create_tables.py` создаст файл `library.db` (если он не существовал) и таблицы, определенные в моделях.

## 3. Определение Моделей и Полей

Поля в Peewee описывают отображение атрибутов модели на столбцы базы данных. Каждому типу поля соответствует определенный класс хранения SQL (например, `varchar`, `int`), а преобразование между типами данных Python и базовым хранилищем обрабатывается прозрачно.4

### Типы полей Peewee

Peewee предлагает широкий набор типов полей для различных данных. В таблице ниже приведены основные типы полей, их аналоги в Python и SQLite, а также некоторые ключевые параметры.

**Таблица 1: Основные типы полей Peewee и их свойства**

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|**Тип поля Peewee**|**Тип Python**|**Тип SQLite**|**Основные параметры (помимо общих)**|**Описание**|**Источник**|
|`CharField`|`str`|`varchar`|`max_length`|Строка с максимальной длиной (0-255 по умолчанию для некоторых баз).|1|
|`TextField`|`str`|`text`||Текстовое поле произвольной длины.|3|
|`IntegerField`|`int`|`integer`||Целое число.|1|
|`BigIntegerField`|`int`|`integer`||Большое целое число (в SQLite также `integer`).|3|
|`SmallIntegerField`|`int`|`integer`||Малое целое число (в SQLite также `integer`).|3|
|`FloatField`|`float`|`real`||Число с плавающей запятой.|1|
|`DoubleField`|`float`|`real`||Число с плавающей запятой двойной точности (в SQLite также `real`).|3|
|`DecimalField`|`Decimal`|`decimal`|`max_digits`, `decimal_places`, `auto_round`, `rounding`|Десятичное число с фиксированной точностью.|3|
|`BooleanField`|`bool`|`smallint`||Булево значение (True/False). В SQLite хранится как 0 или 1.|3|
|`DateField`|`datetime.date`|`date`|`formats`|Дата.|1|
|`TimeField`|`datetime.time`|`time`|`formats`|Время.|3|
|`DateTimeField`|`datetime.datetime`|`datetime`|`formats`|Дата и время.|3|
|`TimestampField`|`int`|`integer`|`resolution`, `utc`|Метка времени (хранится как UNIX timestamp).|3|
|`PrimaryKeyField`|`int`|`integer`||Автоинкрементное целочисленное поле, первичный ключ. (Синоним `AutoField`)|3|
|`AutoField`|`int`|`integer`||Автоинкрементное целочисленное поле, обычно используется для первичных ключей.|3|
|`BigAutoField`|`int`|`integer`||Большое автоинкрементное целочисленное поле.|3|
|`ForeignKeyField`|Экземпляр модели|`integer`|`model` (или `to`), `field`, `backref`, `on_delete`, `on_update`, `lazy_load`|Внешний ключ, связывающий с другой моделью.|3|
|`BlobField`|`bytes`|`blob`||Бинарные данные (BLOB).|3|
|`UUIDField`|`UUID`|`text`||UUID. В SQLite хранится как текст.|3|
|`FixedCharField`|`str`|`char`|`max_length`|Строка фиксированной длины.|3|
|`IPField`|`str`|`integer`||IP-адрес (хранится как целое число для IPv4).|3|

### Общие свойства полей

Все типы полей принимают ряд общих параметров при инициализации 3:

- `null` (bool): Если `True`, полю разрешено хранить значение `NULL`. По умолчанию `False` (поле не может быть `NULL`). 1
    - Ненулевые поля (`null=False`) требуют либо значения по умолчанию, либо явного значения при создании записи.6
- `index` (bool): Если `True`, для этого столбца будет создан индекс. По умолчанию `False`. (В старых версиях `db_index`) 3
- `unique` (bool): Если `True`, для этого столбца будет создан уникальный индекс, гарантирующий, что все значения в столбце уникальны. По умолчанию `False`. 3
- `default`: Значение по умолчанию для поля, если оно не указано при создании записи. Может быть значением или вызываемым объектом (например, `datetime.datetime.now`). 5
    - Для изменяемых типов по умолчанию (например, списков) следует использовать `lambda`, чтобы избежать использования одного и того же экземпляра для всех объектов: `default=lambda:`.6
- `primary_key` (bool): Если `True`, это поле будет первичным ключом таблицы. По умолчанию `False`. Если первичный ключ не указан явно, Peewee автоматически создает поле `id` типа `AutoField`. 3
- `column_name` (str): Позволяет явно указать имя столбца в базе данных, если оно должно отличаться от имени атрибута модели. 3
- `constraints` (list): Список дополнительных SQL-ограничений, применяемых к полю, например, ``. 5
- `sequence` (str): Имя последовательности для автоинкрементных полей (актуально для СУБД, поддерживающих последовательности, например, PostgreSQL).
- `choices` (iterable): Итерируемый объект из 2-кортежей, отображающий значения столбцов на их отображаемые метки (для информации, не влияет на схему БД). 8
- `help_text` (str): Текст помощи для поля, используется в целях метаданных. 4
- `verbose_name` (str): "Человекочитаемое" имя поля, используется в целях метаданных. 4

### Специальные параметры полей

Некоторые типы полей имеют дополнительные специфичные параметры 3:

- `CharField`, `FixedCharField`:
    - `max_length` (int): Обязательный параметр, максимальная длина строки.
- `DateTimeField`, `DateField`, `TimeField`:
    - `formats` (list): Список строковых форматов, которые будут использоваться для разбора входящих строковых значений в объекты даты/времени. Например, `['%Y-%m-%d', '%d.%m.%Y']`. Если входящее значение не соответствует ни одному формату, оно будет возвращено как есть.4
- `DecimalField`:
    - `max_digits` (int): Максимальное количество цифр.
    - `decimal_places` (int): Количество знаков после запятой.
    - `auto_round` (bool): Автоматически округлять значения.
    - `rounding` (str): Метод округления (например, `ROUND_HALF_UP` из модуля `decimal`).
- `ForeignKeyField`:
    - `model` (или `to` в старых версиях): Класс модели, на которую ссылается внешний ключ. Может быть строкой `'self'` для рекурсивных связей. 3
    - `field` (Field): Поле в связанной модели, на которое указывает ключ (по умолчанию первичный ключ связанной модели). 3
    - `backref` (str): Имя атрибута, который будет создан на связанной модели для обратного доступа к объектам текущей модели. Например, если `Tweet.user = ForeignKeyField(User, backref='tweets')`, то у экземпляра `User` будет доступен атрибут `user.tweets`, возвращающий запрос на все твиты этого пользователя. 3
    - `on_delete` (str): Действие при удалении связанной записи (например, `'CASCADE'`, `'SET NULL'`, `'RESTRICT'`). Для SQLite необходимо включить `PRAGMA foreign_keys=ON;` для корректной работы `ON DELETE`.10
    - `on_update` (str): Действие при обновлении связанной записи.
    - `lazy_load` (bool): Если `True` (по умолчанию), связанный объект будет загружен при первом обращении к атрибуту внешнего ключа. Если `False`, обращение к атрибуту вернет только значение ID из столбца внешнего ключа. 3
- `TimestampField`:
    - `resolution` (int): Разрешение метки времени (например, количество микросекунд).
    - `utc` (bool): Если `True`, метка времени будет храниться в UTC.

### Валидаторы и ограничения полей

Peewee не имеет встроенной системы валидации на уровне моделей, подобной той, что есть в Django. Однако проверка данных может быть реализована несколькими способами:

1. **Ограничения на уровне базы данных:**
    
    - `null=False`: Поле не может быть пустым.
    - `unique=True`: Значение поля должно быть уникальным в таблице.
    - `primary_key=True`: Поле является первичным ключом (подразумевает `null=False` и `unique=True`).
    - `constraints=[Check(...)]`: Позволяет определить произвольные `CHECK` ограничения на уровне SQL. Например, `IntegerField(constraints=[Check('age >= 18')])` создаст SQL-ограничение, что значение в столбце `age` должно быть не меньше 18.7 Если ограничение нарушено, база данных вернет ошибку (`peewee.IntegrityError`).
    - `ForeignKeyField` также обеспечивает ссылочную целостность.
2. **Параметр `default`:**
    
    - Обеспечивает наличие значения, если оно не предоставлено.6
3. **Пользовательские методы валидации в модели:**
    
    - Можно определить собственные методы в классе модели, которые будут вызываться перед сохранением (например, переопределив метод `save()`).
4. **Внешние библиотеки валидации:**
    
    - Существуют сторонние библиотеки, такие как `peewee-validates`, которые добавляют более сложную логику валидации для моделей Peewee.11 Эти библиотеки предоставляют классы `Validator` и различные встроенные валидаторы (`validate_not_empty()`, `validate_email()`, `validate_length()` и т.д.), а также возможность создавать пользовательские валидаторы. `ModelValidator` из этой библиотеки может автоматически добавлять валидаторы на основе свойств полей модели, таких как `unique=True` или `ForeignKeyField`.11

Понимание того, как эти ограничения работают, помогает обеспечить целостность данных на уровне базы данных. Например, `null=False` гарантирует, что обязательные поля всегда будут заполнены, а `unique=True` предотвращает дублирование записей по определенным полям. Использование `Check` ограничений позволяет реализовать более сложную бизнес-логику непосредственно в схеме БД.7

## 4. Основные CRUD-операции

CRUD — это акроним для четырех основных функций, реализуемых при работе с базами данных: Создание (Create), Чтение (Read), Обновление (Update) и Удаление (Delete). Peewee предоставляет интуитивно понятные методы для выполнения этих операций.

### Создание записей (Create)

Существует несколько способов добавления новых записей в таблицу с помощью Peewee:

- **`Model.create(**kwargs)`**: Наиболее простой и распространенный способ. Метод принимает именованные аргументы, соответствующие полям модели, создает экземпляр модели, сохраняет его в базе данных и возвращает сохраненный экземпляр.1
    
    - Пример: `book = Book.create(title='The Hitchhiker\'s Guide to the Galaxy', author='Douglas Adams')`
    - Возвращает: Экземпляр созданной модели (`Book` в данном случае).
- **Создание экземпляра и вызов `instance.save()`**: Сначала создается экземпляр модели, затем вызывается его метод `save()` для сохранения в БД.2
    
    - Пример:
        
        Python
        
        ```
        from datetime import date
        uncle_bob = Person(name='Bob', birthday=date(1960, 1, 15))
        uncle_bob.save() # bob теперь сохранен в базе данных
        ```
        
    - `save()` возвращает количество измененных строк (1 для новой записи).2 Если у модели есть автоинкрементный первичный ключ, он будет установлен на экземпляре после вызова `save()`.14
- **`Model.insert(**kwargs).execute()`**: Конструирует SQL INSERT-запрос и выполняет его. Возвращает ID вставленной записи (поведение может зависеть от используемой СУБД и ее конфигурации).2
    
    - Пример: `query = User.insert(name='Lata', age=20)`
    - `inserted_id = query.execute()`
- **Массовое создание записей:** Для вставки нескольких записей одновременно Peewee предлагает более эффективные методы, чем выполнение `create()` или `save()` в цикле. Использование пакетных операций значительно снижает количество обращений к базе данных и накладные расходы Python, что критично для производительности при работе с большими объемами данных.13
    
    - `Model.insert_many(rows).execute()`: Принимает список словарей (`rows`), где каждый словарь представляет одну запись, или список кортежей. Если передаются кортежи, необходимо также указать параметр `fields`, перечисляющий поля модели в том же порядке, что и значения в кортежах. Этот метод генерирует один SQL INSERT-запрос для нескольких строк.2
        - Пример со словарями:
            
            Python
            
            ```
            user_data =
            User.insert_many(user_data).execute()
            ```
            
        - Пример с кортежами:
            
            Python
            
            ```
            user_data_tuples =
            User.insert_many(user_data_tuples, fields=[User.username, User.email]).execute()
            ```
            
    - `Model.bulk_create(instances, batch_size=N)`: Принимает список несохраненных экземпляров модели (`instances`) и вставляет их в базу данных, опционально разбивая на пакеты размером `batch_size`. Для PostgreSQL, если используется `RETURNING clause`, этот метод может автоматически заполнить значения первичных ключей на переданных экземплярах моделей.2
        - Пример:
            
            Python
            
            ```
            users_to_create = [User(username='Eve'), User(username='Frank')]
            User.bulk_create(users_to_create, batch_size=50)
            ```
            

Выбор между `Model.create()` и `instance.save()` часто является вопросом стиля, но `create()` более лаконичен для одношагового создания и сохранения. Для массовых вставок `insert_many()` или `bulk_create()` являются предпочтительными из-за их производительности.

### Чтение записей (Read)

Peewee предоставляет гибкие способы извлечения данных из базы.

- **`Model.select(*fields)`**: Основной метод для построения SELECT-запросов. Если аргументы `*fields` не указаны, выбираются все поля модели. Метод не выполняет запрос немедленно, а возвращает объект `ModelSelect`, который является построителем запроса и итерируемым объектом.2 Запрос к базе данных выполняется при начале итерации по объекту `ModelSelect` или при вызове методов, требующих данных (например, `list()`, `get()`, `count()`).
    
    - Пример выборки всех записей:
        
        Python
        
        ```
        for user in User.select():
            print(user.username, user.email)
        ```
        
    - Пример выборки конкретных полей:
        
        Python
        
        ```
        query = User.select(User.username, User.email)
        for user_data in query: # user_data будет экземпляром User, но содержать только username и email
            print(user_data.username)
        ```
        
    - По умолчанию результаты запроса `select()` кэшируются в памяти в виде экземпляров моделей. Для очень больших выборок, чтобы избежать излишнего потребления памяти, можно использовать метод `.iterator()`, который будет получать строки из базы данных по одной, не кэшируя их все.13
        
        Python
        
        ```
        for user in User.select().iterator():
            # Обработка большого количества пользователей без загрузки всех в память
            process_user(user)
        ```
        
- **`Model.get(*expressions)`** или **`Model.select().where(*expressions).get()`**: Получает одну запись, соответствующую указанным условиям (`*expressions`). Если запись не найдена, выбрасывается исключение `Model.DoesNotExist` (например, `User.DoesNotExist`). Если найдено несколько записей, удовлетворяющих условиям, будет возвращена первая из них.2
    
    - Пример: `alice = User.get(User.username == 'Alice')`
    - Исключение `DoesNotExist` специфично для каждой модели, поэтому правильнее отлавливать `User.DoesNotExist`, `Book.DoesNotExist` и т.д.
    - Обязательная обработка исключения `DoesNotExist` делает код более надежным и предотвращает падение программы, если ожидаемая запись отсутствует.
        
        Python
        
        ```
        try:
            user = User.get(User.username == 'non_existent_user')
            print(f"User found: {user.username}")
        except User.DoesNotExist:
            print("User not found.")
        ```
        
- **`Model.get_by_id(pk_value)`**: Удобный шорткат для получения записи по ее первичному ключу. Эквивалентно `Model.get(Model._meta.primary_key == pk_value)`. Также выбрасывает `DoesNotExist`, если запись не найдена.15
    
    - Пример: `user = User.get_by_id(1)`
- **`Model.get_or_create(defaults=None, **kwargs)`**: Пытается получить запись, используя условия из `**kwargs`. Если запись найдена, она возвращается. Если не найдена, создается новая запись с использованием значений из `**kwargs` и опционального словаря `defaults` (значения из `defaults` используются только при создании). Метод возвращает кортеж `(instance, created)`, где `instance` — это экземпляр модели, а `created` — булево значение, указывающее, была ли запись создана (`True`) или найдена (`False`).2
    
    - `kwargs` используются для фильтрации при поиске (в `WHERE` части запроса).
    - `defaults` (словарь) используется для задания дополнительных значений полей при создании новой записи, если она не была найдена.
    - Пример:
        
        Python
        
        ```
        user, created = User.get_or_create(
            username='Bob',
            defaults={'email': 'bob_new@example.com', 'is_active': True}
        )
        if created:
            print(f"User {user.username} created.")
        else:
            print(f"User {user.username} found.")
        ```
        
    - Этот метод полезен для идиомы "upsert" (update or insert), особенно когда нужно гарантировать наличие записи с определенными уникальными полями. Следует использовать с осторожностью в высоконагруженных системах из-за возможных состояний гонки, если не обернуто в транзакцию с соответствующим уровнем изоляции или если нет уникального ограничения на уровне БД.24

#### Что возвращают методы выборок и как этим пользоваться

Методы выборки в Peewee могут возвращать данные в различных форматах, что позволяет выбрать наиболее подходящий для конкретной задачи:

- **Экземпляры моделей (по умолчанию для `select()`, `get()`):** Каждая строка результата преобразуется в экземпляр соответствующей модели. Это позволяет обращаться к полям как к атрибутам объекта (например, `user.username`, `book.title`) и вызывать методы модели. Это наиболее объектно-ориентированный способ работы с данными.2
    
    Python
    
    ```
    users = User.select().where(User.is_active == True)
    for user in users:
        print(f"Username: {user.username}, Email: {user.email}")
        user.send_welcome_email() # Пример вызова метода модели
    ```
    
- **`.dicts()`**: Возвращает результаты запроса в виде списка словарей Python. Ключами в словарях являются имена полей (или псевдонимы, если они были заданы в `select()`). Этот формат удобен для сериализации данных (например, в JSON) или когда не требуется вся функциональность объектов моделей.10
    
    Python
    
    ```
    user_data_list = User.select(User.username, User.email).dicts()
    for user_data in user_data_list:
        print(f"Username: {user_data['username']}, Email: {user_data['email']}")
    ```
    
- **`.tuples()`**: Возвращает результаты запроса в виде списка кортежей. Порядок значений в кортежах соответствует порядку полей, указанных в `select()`. Этот формат может быть наиболее эффективным по памяти, если требуется только значения.13
    
    Python
    
    ```
    user_data_tuples = User.select(User.username, User.email).tuples()
    for username, email in user_data_tuples:
        print(f"Username: {username}, Email: {email}")
    ```
    
- **`.namedtuples()`**: Возвращает результаты в виде списка именованных кортежей (`collections.namedtuple`). Это компромисс между словарями и обычными кортежами, позволяя обращаться к значениям как по индексу, так и по имени атрибута.13
    
    Python
    
    ```
    user_data_namedtuples = User.select(User.username, User.email).namedtuples()
    for user_data in user_data_namedtuples:
        print(f"Username: {user_data.username}, Email: {user_data.email}")
    ```
    
- **`.scalar(database, as_tuple=False, as_dict=False)`**: Извлекает одно скалярное значение из первой строки результата запроса. Обычно используется с агрегатными функциями (например, `fn.COUNT()`, `fn.SUM()`) или когда запрос гарантированно возвращает одно значение. Требует явной передачи объекта базы данных `db`.13
    
    Python
    
    ```
    from peewee import fn
    total_users = User.select(fn.COUNT(User.id)).scalar(db)
    print(f"Total users: {total_users}")
    
    # Если запрос возвращает несколько значений в строке, но нужно одно
    max_price = Book.select(fn.MAX(Book.price)).scalar(db)
    
    # Получение нескольких скалярных значений как кортежа
    stats = Book.select(fn.COUNT(Book.id), fn.AVG(Book.price)).scalar(db, as_tuple=True)
    print(f"Total books: {stats}, Average price: {stats}")
    ```
    
    Параметры `as_tuple=True` или `as_dict=True` позволяют вернуть первую строку результата как кортеж или словарь соответственно, если запрос выбирает несколько столбцов.26
    
- **`.objects()`**: Возвращает экземпляры моделей, как и стандартный `select()`, но при наличии JOIN-ов не пытается реконструировать полный граф связанных объектов. Это может быть полезно для производительности в сложных запросах с множественными объединениями, если доступ к связанным объектам через атрибуты не требуется, а нужны только данные из основной модели и, возможно, плоский список атрибутов из присоединенных таблиц.10
    

Выбор формата возвращаемых данных зависит от конкретной задачи. Для полной объектно-ориентированной работы с записями и их связанными данными экземпляры моделей являются стандартом. Если же требуется быстрая сериализация, передача данных или работа только с определенными значениями без накладных расходов на создание объектов моделей, то `.dicts()`, `.tuples()` или `.scalar()` могут быть более эффективными.

### Обновление записей (Update)

Peewee предлагает несколько способов изменения существующих записей:

- **Получение экземпляра, изменение атрибутов и вызов `instance.save()`**: Это наиболее объектно-ориентированный подход. Сначала извлекается экземпляр модели, затем изменяются его атрибуты, и после этого вызывается метод `save()` для сохранения изменений в базе данных.2
    
    Python
    
    ```
    user = User.get(User.username == 'Alice')
    user.email = 'alice_updated@example.com'
    user.save() # Сохраняет изменения в БД
    ```
    
    - Метод `save()` возвращает количество измененных строк (обычно 1, если запись была фактически изменена, или 0, если изменений не было и, например, в `Meta` модели установлено `only_save_dirty=True`).2 Peewee определяет, выполнять `INSERT` или `UPDATE`, по наличию значения первичного ключа у экземпляра.3
    - **Частичное обновление с `instance.save(only=[...])`**: Можно указать список полей, которые должны быть обновлены, передав их в параметр `only`. Это полезно для частичных обновлений и предотвращает перезапись других полей, которые могли быть изменены другим процессом или не были включены в форму обновления.2
        
        Python
        
        ```
        user.notes = "New notes"
        # Обновит только поле notes, даже если email тоже был изменен на экземпляре user
        user.save(only=[User.notes])
        ```
        
        Использование `save(only=...)` особенно важно в веб-приложениях, где данные формы могут содержать не все поля модели, или для предотвращения случайной перезаписи полей, которые не должны были изменяться данной операцией.
- **`Model.update(**kwargs).where(*expressions).execute()`**: Этот метод используется для пакетного обновления записей, удовлетворяющих условиям, указанным в `.where()`. Аргументы `**kwargs` представляют собой словарь, где ключи — это поля модели, а значения — новые значения для этих полей. Метод `execute()` выполняет запрос и возвращает количество обновленных строк.2
    
    - Пример:
        
        Python
        
        ```
        query = User.update(is_active=False, last_login=None).where(User.logins_count < 5)
        updated_rows_count = query.execute()
        print(f"Deactivated {updated_rows_count} users.")
        ```
        
    - В качестве значений можно использовать SQL-выражения, включая ссылки на другие поля той же таблицы или вызовы функций `fn()`:
        
        Python
        
        ```
        # Увеличить счетчик логинов для конкретного пользователя
        User.update(logins_count=User.logins_count + 1).where(User.id == 1).execute()
        # Установить скидку на основе текущей цены
        Product.update(discount_price=Product.price * 0.9).where(Product.category == 'sale').execute()
        ```
        
        17
    - Пакетное обновление с помощью `Model.update()` значительно производительнее, чем извлечение каждой записи в цикле и последующее сохранение через `instance.save()`, так как выполняется один SQL-запрос `UPDATE`.
- **`Model.bulk_update(instances, fields, batch_size=N)`**: Эффективно обновляет список уже существующих экземпляров моделей (`instances`) по указанным полям (`fields`). Этот метод генерирует один SQL-запрос `UPDATE` с использованием конструкции `CASE... WHEN... THEN... END` для установки различных значений для разных строк на основе их первичных ключей. Опциональный параметр `batch_size` позволяет разбить операцию на несколько запросов, если список экземпляров очень большой.2
    
    - Пример:
        
        Python
        
        ```
        user1 = User.get(User.id == 1)
        user2 = User.get(User.id == 2)
        user1.email = 'new_email1@example.com'
        user1.is_active = False
        user2.email = 'new_email2@example.com'
        User.bulk_update([user1, user2], fields=[User.email, User.is_active])
        ```
        

### Удаление записей (Delete)

Peewee также предоставляет несколько способов удаления записей:

- **`instance.delete_instance(recursive=False, delete_nullable=False)`**: Удаляет из базы данных запись, соответствующую данному экземпляру модели. Возвращает количество удаленных строк (обычно 1).2
    
    - `recursive=True`: Если установлено в `True`, Peewee попытается также удалить все зависимые записи (т.е. записи в других таблицах, которые ссылаются на удаляемую запись через внешние ключи с настроенным каскадным удалением или если Peewee может определить эти зависимости).
    - `delete_nullable=True`: При рекурсивном удалении, если зависимое поле внешнего ключа допускает `NULL`, оно будет установлено в `NULL` вместо удаления зависимой записи (если `recursive=True`).
    - Пример:
        
        Python
        
        ```
        user_to_delete = User.get(User.username == 'obsolete_user')
        deleted_count = user_to_delete.delete_instance()
        if deleted_count > 0:
            print(f"User {user_to_delete.username} deleted.")
        ```
        
- **`Model.delete().where(*expressions).execute()`**: Используется для пакетного удаления записей, удовлетворяющих условиям, указанным в `.where()`. Метод `execute()` выполняет запрос и возвращает количество удаленных строк.2
    
    - Пример:
        
        Python
        
        ```
        query = Tweet.delete().where(Tweet.is_spam == True)
        deleted_tweets_count = query.execute()
        print(f"Deleted {deleted_tweets_count} spam tweets.")
        ```
        
    - **Критически важно:** Всегда используйте метод `.where()` при пакетном удалении, если вы не намерены удалить все записи из таблицы. Вызов `Model.delete().execute()` без `.where()` приведет к удалению всех строк в таблице, что может быть катастрофической ошибкой для ваших данных.27 Перед выполнением массового удаления рекомендуется сначала проверить, какие записи будут затронуты, с помощью аналогичного запроса `select()`.
        
        Python
        
        ```
        # Сначала проверяем, что будет удалено
        doomed_users = User.select().where(User.last_login < a_very_old_date)
        print(f"Found {doomed_users.count()} users to delete.")
        # Если все верно, выполняем удаление
        # User.delete().where(User.last_login < a_very_old_date).execute()
        ```
        

Метод `delete_instance()` удобен, когда у вас уже есть объект, который нужно удалить. Для удаления записей по условию без предварительного их извлечения `Model.delete().where()` является более эффективным решением.

### Таблица 2: Основные методы CRUD и их параметры

|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|**Метод**|**Тип (Экземпляр/Класс)**|**Описание**|**Основные параметры**|**Возвращаемое значение**|**Пример использования**|**Источник**|
|`create`|Класс|Создает экземпляр модели, сохраняет его в БД и возвращает.|`**kwargs` (поля модели и их значения)|Экземпляр созданной модели.|`User.create(username='new', email='new@ex.com')`|1|
|`save`|Экземпляр|Сохраняет изменения экземпляра в БД (INSERT для новых, UPDATE для существующих).|`force_insert=False` (bool), `only=None` (список полей для обновления)|Количество измененных строк (обычно 1 для INSERT/UPDATE, 0 если нет изменений и `only_save_dirty=True`).|`user = User(name='a'); user.save()` <br> `user.name='b'; user.save()` <br> `user.save(only=[User.name])`|2|
|`select`|Класс|Конструирует SELECT-запрос.|`*fields` (поля для выборки, необязательно)|Объект `ModelSelect` (итерируемый построитель запроса).|`User.select()` <br> `User.select(User.username, User.email)`|2|
|`get`|Класс/ModelSelect|Получает одну запись. Выбрасывает `DoesNotExist`, если не найдена.|`*expressions` (условия для `Model.get()`)|Экземпляр найденной модели.|`User.get(User.id == 1)` <br> `User.select().where(User.id == 1).get()`|2|
|`get_by_id`|Класс|Получает одну запись по первичному ключу. Выбрасывает `DoesNotExist`.|`pk_value` (значение первичного ключа)|Экземпляр найденной модели.|`User.get_by_id(1)`|15|
|`get_or_create`|Класс|Пытается получить запись; если не найдена, создает новую.|`defaults=None` (dict), `**kwargs` (условия поиска и значения для создания)|Кортеж `(instance, created_boolean)`.|`User.get_or_create(username='bob', defaults={'email':'b@ex.com'})`|2|
|`update`|Класс|Пакетное обновление записей, соответствующих условию.|`**kwargs` (словарь {поле: новое_значение})|Объект `UpdateQuery` (для последующего `.where().execute()`). `execute()` возвращает количество обновленных строк.|`User.update(is_active=False).where(User.logins < 1).execute()`|2|
|`delete_instance`|Экземпляр|Удаляет запись, соответствующую экземпляру.|`recursive=False` (bool), `delete_nullable=False` (bool)|Количество удаленных строк (обычно 1).|`user = User.get(id=1); user.delete_instance()`|2|
|`delete`|Класс|Пакетное удаление записей, соответствующих условию.||Объект `DeleteQuery` (для последующего `.where().execute()`). `execute()` возвращает количество удаленных строк.|`User.delete().where(User.is_active == False).execute()`|2|
|`insert_many`|Класс|Массовая вставка записей (список словарей или кортежей).|`rows` (list of dicts/tuples), `fields=None` (list of Field, если rows - кортежи)|Объект `InsertQuery`. `execute()` обычно возвращает ID последней вставленной записи или количество вставленных строк.|`User.insert_many([{'name':'a'}, {'name':'b'}]).execute()`|2|
|`bulk_create`|Класс|Массовая вставка записей (список несохраненных экземпляров).|`instances` (list of Model instances), `batch_size=None` (int)|Зависит от СУБД (может ничего не возвращать или заполнять PK на экземплярах для PostgreSQL).|`User.bulk_create([User(name='a'), User(name='b')])`|2|
|`bulk_update`|Класс|Массовое обновление записей (список существующих экземпляров).|`instances` (list of Model instances), `fields` (list of Field to update), `batch_size=None` (int)|Количество обновленных строк.|`User.bulk_update([u1, u2], fields=[User.email])`|2|

Эта таблица служит кратким справочником по основным методам для выполнения CRUD-операций, что особенно полезно для новичков, чтобы быстро начать взаимодействовать с базой данных.

## 5. Формирование Запросов (Querying)

Peewee предоставляет мощный и гибкий API для построения SQL-запросов. Центральным элементом является метод `.select()`, к которому затем применимы различные методы для фильтрации, сортировки, группировки и т.д.

### Фильтрация данных с помощью `.where(*expressions)`

Метод `.where()` используется для добавления условий фильтрации к запросу (аналог SQL `WHERE`). Он принимает одно или несколько выражений, которые объединяются логическим `AND` по умолчанию.2

**Операторы сравнения:**

- `Model.field == value`: Равно (`=`). Пример: `User.select().where(User.username == 'Charlie')`.13
- `Model.field!= value`: Не равно (`!=`). Пример: `User.select().where(User.status!= 'inactive')`.13
- `Model.field > value`: Больше (`>`). Пример: `Product.select().where(Product.price > 100.0)`.13
- `Model.field < value`: Меньше (`<`). Пример: `Event.select().where(Event.date < date(2023, 1, 1))`.13
- `Model.field >= value`: Больше или равно (`>=`)..13
- `Model.field <= value`: Меньше или равно (`<=`)..13

**Операторы принадлежности:**

- `Model.field << [...]` или `Model.field.in_([...])`: Значение поля содержится в списке (SQL `IN`). Пример: `User.select().where(User.status.in_(['active', 'pending']))`.13
- `Model.field.not_in_([...])`: Значение поля не содержится в списке (SQL `NOT IN`). Пример: `Tweet.select().where(Tweet.user.not_in(banned_users_query))`.13

**Проверка на `NULL`:**

- `Model.field >> None` или `Model.field.is_null(True)`: Поле имеет значение `NULL` (SQL `IS NULL`). Пример: `Product.select().where(Product.description.is_null(True))`.13
- `Model.field.is_null(False)`: Поле не имеет значения `NULL` (SQL `IS NOT NULL`). Пример: `Order.select().where(Order.shipped_date.is_null(False))`.13

Строковые операции:

Поведение строковых операций, таких как LIKE, может зависеть от используемой СУБД и ее настроек (например, чувствительность к регистру). В SQLite операция LIKE по умолчанию регистронезависима, в то время как GLOB регистрозависима и использует * и ? в качестве метасимволов вместо % и _.33 Peewee пытается это унифицировать.

- `Model.field % 'pattern'`: Поиск по шаблону (SQL `LIKE`). `pattern` может содержать метасимволы `%` (любая последовательность символов) и `_` (любой одиночный символ). Пример: `User.select().where(User.email % '%@example.com')`.13
- `Model.field ** 'pattern'`: Регистронезависимый поиск по шаблону (SQL `ILIKE` в PostgreSQL, или эмулируется через `LOWER()` в других СУБД, если необходимо). Пример: `Book.select().where(Book.title ** '%guide%')`.13
- `Model.field.contains('substring')`: Поле содержит подстроку (`LIKE '%substring%'`). Пример: `Article.select().where(Article.content.contains('Peewee ORM'))`.13
- `Model.field.startswith('prefix')`: Поле начинается с префикса (`LIKE 'prefix%'`). Пример: `User.select().where(User.username.startswith('admin_'))`.13
- `Model.field.endswith('suffix')`: Поле заканчивается суффиксом (`LIKE '%suffix'`). Пример: `File.select().where(File.name.endswith('.txt'))`.13

**Диапазоны:**

- `Model.field.between(low, high)`: Значение поля находится в диапазоне между `low` и `high` включительно (SQL `BETWEEN low AND high`). Пример: `Product.select().where(Product.price.between(10.0, 50.0))`.13

Логические операторы (для объединения выражений):

Для объединения нескольких условий используются побитовые операторы Python:

- `&` (логическое И, SQL `AND`): Оба условия должны быть истинны. Пример: `User.select().where((User.is_admin == True) & (User.last_login >= date(2023,1,1)))`.13
- `|` (логическое ИЛИ, SQL `OR`): Хотя бы одно из условий должно быть истинно. Пример: `User.select().where((User.status == 'admin') | (User.status == 'editor'))`.13
- `~` (логическое НЕ, SQL `NOT`): Инвертирует условие. Пример: `User.select().where(~(User.email % '%@spam.com'))`.13

**Важность скобок:** Из-за стандартного приоритета операторов в Python, при комбинировании `&` и `|` в одном выражении необходимо использовать скобки для явного указания порядка выполнения, чтобы избежать неожиданных результатов. Например, `(condition1 & condition2) | condition3` отличается от `condition1 & (condition2 | condition3)`.13

Одна из частых ошибок, с которой сталкиваются новички, — это попытка использовать стандартные логические операторы Python `and`, `or`, `not` вместо перегруженных Peewee операторов `&`, `|`, `~`. Стандартные операторы Python не могут быть перегружены для построения SQL-выражений и будут интерпретироваться как обычные логические операции Python над результатами выражений (которые обычно приводятся к `True` или `False`), что приведет к неверным SQL-запросам или ошибкам времени выполнения. Поэтому критически важно запомнить и использовать именно `&`, `|` и `~`.

### Таблица 3: Операторы фильтрации Peewee и их SQL-аналоги

|                                |                                                       |                        |                                                                |
| ------------------------------ | ----------------------------------------------------- | ---------------------- | -------------------------------------------------------------- |
| **Оператор Peewee**            | **Пример использования Peewee**                       | **SQL-аналог**         | **Описание**                                                   |
| `==`                           | `User.username == 'Alice'`                            | `= 'Alice'`            | Равенство                                                      |
| `!=`                           | `User.status!= 'inactive'`                            | `!= 'inactive'`        | Неравенство                                                    |
| `>`                            | `Product.price > 100`                                 | `> 100`                | Больше                                                         |
| `<`                            | `Event.id < 1000`                                     | `< 1000`               | Меньше                                                         |
| `>=`                           | `Order.quantity >= 5`                                 | `>= 5`                 | Больше или равно                                               |
| `<=`                           | `Stock.level <= 10`                                   | `<= 10`                | Меньше или равно                                               |
| `<< [...]` или `.in_([...])`   | `User.id <<`                                          | `IN (1, 2, 3)`         | Значение входит в список                                       |
| `.not_in_([...])`              | `User.id.not_in_()`                                   | `NOT IN (4, 5)`        | Значение не входит в список                                    |
| `>> None` или `.is_null(True)` | `Profile.bio >> None`                                 | `IS NULL`              | Значение равно NULL                                            |
| `.is_null(False)`              | `Profile.bio.is_null(False)`                          | `IS NOT NULL`          | Значение не равно NULL                                         |
| `% 'шаблон'`                   | `User.email % '%@example.com'`                        | `LIKE '%@example.com'` | Поиск по шаблону (чувствительность к регистру зависит от СУБД) |
| `** 'шаблон'`                  | `Product.name ** '%apple%'`                           | `ILIKE '%apple%'`      | Поиск по шаблону (регистронезависимый)                         |
| `.contains('str')`             | `Article.title.contains('Peewee')`                    | `LIKE '%Peewee%'`      | Содержит подстроку                                             |
| `.startswith('str')`           | `User.username.startswith('guest_')`                  | `LIKE 'guest_%'`       | Начинается с подстроки                                         |
| `.endswith('str')`             | `File.name.endswith('.jpg')`                          | `LIKE '%.jpg'`         | Заканчивается подстрокой                                       |
| `.between(a, b)`               | `Product.price.between(10, 20)`                       | `BETWEEN 10 AND 20`    | Значение находится в диапазоне (включительно)                  |
| `&`                            | `(User.is_active == True) & (User.is_admin == True)`  | `AND`                  | Логическое И                                                   |
| `\|`                           | `(User.role == 'admin') \|(User.role == 'moderator')` |                        |                                                                |
| `~`                            | `~(User.email % '%spam%')`                            | `NOT`                  | Логическое НЕ                                                  |

Эта таблица поможет пользователям, уже знакомым с SQL, быстрее освоить синтаксис фильтрации в Peewee, проводя параллели с известными им SQL-конструкциями.

### Повторные фильтрации

Peewee позволяет строить запросы динамически, добавляя условия `.where()` по мере необходимости. Каждый последующий вызов `.where()` к одному и тому же объекту запроса добавит новые условия, объединив их с предыдущими через логическое `AND`.

Python

```
query = User.select().where(User.is_active == True)

if request.GET.get('is_staff'):
    query = query.where(User.is_staff == True) # Добавляется через AND

if request.GET.get('department'):
    query = query.where(User.department == request.GET.get('department')) # И еще одно AND

users = list(query)
```

Это эквивалентно одному вызову `.where()` со всеми условиями, объединенными через `&`. Такой подход делает код более гибким и читаемым, особенно когда фильтры зависят от внешних условий (например, параметров HTTP-запроса).

Для добавления условия через `OR` к уже существующим можно использовать метод `.orwhere(*expressions)`.26

Python

```
query = User.select().where(User.username == 'Alice')
# Добавит (User.email == 'alice@example.com') через OR к существующему условию
query = query.orwhere(User.email == 'alice@example.com')
# SQL: WHERE (username = 'Alice') OR (email = 'alice@example.com')
```

Возможность пошагового построения запроса упрощает разработку сложных систем фильтрации и делает код более модульным.

## 6. Объединение Таблиц (JOIN)

Объединение таблиц (JOIN) является фундаментальной операцией в реляционных базах данных, позволяющей комбинировать строки из двух или более таблиц на основе связанных столбцов. Peewee предоставляет мощный и гибкий API для выполнения JOIN-операций.

### Метод `.join()`

Основным методом для объединения таблиц в Peewee является Model.join().2

Синтаксис: Query.join(TargetModel, join_type=JOIN.INNER, on=None, attr=None)

- `TargetModel`: Класс модели, с которой происходит объединение.
- `join_type` (опционально): Тип объединения. По умолчанию используется `JOIN.INNER`. Peewee определяет константы для различных типов JOIN в объекте `JOIN` (например, `JOIN.LEFT_OUTER`).
- `on` (опционально): Явное условие объединения. Это должно быть выражение Peewee (например, `Tweet.user_id == User.id`). Используется, когда Peewee не может автоматически определить условие объединения (например, при отсутствии явного `ForeignKeyField`, наличии нескольких `ForeignKeyField` к одной и той же таблице, или при объединении по полям, не являющимся внешними ключами).
- `attr` (опционально): Если указано имя атрибута, то экземпляр присоединенной модели будет доступен через этот атрибут на экземпляре основной модели. Это полезно для ясности или когда есть несколько JOIN-ов к одной и той же модели. Например, `Tweet.select().join(User, attr='author')` позволит обращаться к пользователю как `tweet.author`.

### Типы объединений

Peewee поддерживает стандартные типы SQL JOIN 2:

- **`JOIN.INNER` (по умолчанию):** Возвращает только те строки, для которых существует совпадение в обеих объединяемых таблицах.
    
    Python
    
    ```
    # Выбрать всех пользователей, у которых есть твиты
    query = User.select(User.username, Tweet.content).join(Tweet)
    ```
    
- **`JOIN.LEFT_OUTER` (или `JOIN.LEFT`):** Возвращает все строки из "левой" таблицы (таблицы, указанной в `Model.select()`) и совпадающие строки из "правой" таблицы (таблицы, указанной в `join()`). Если совпадения в правой таблице нет, то для ее полей будут возвращены значения `NULL`. Это полезно, когда нужно получить все записи из одной таблицы и, если есть, связанные с ними данные из другой.
    
    Python
    
    ```
    # Выбрать всех пользователей и их твиты (если есть)
    # Пользователи без твитов также будут в результате, но поля Tweet будут NULL
    query = User.select(User.username, Tweet.content).join(Tweet, JOIN.LEFT_OUTER)
    ```
    
- Другие типы JOIN, такие как `JOIN.RIGHT_OUTER`, `JOIN.FULL_OUTER`, `JOIN.CROSS`, также поддерживаются, но используются реже.34

### Условия объединения

- **Неявное условие (через `ForeignKeyField`):** Если между моделями определен `ForeignKeyField`, Peewee обычно может автоматически определить условие для JOIN на основе этого внешнего ключа. Это наиболее частый случай.2
    
    Python
    
    ```
    # Предполагается, что модель Tweet имеет поле user = ForeignKeyField(User)
    query = Tweet.select().join(User).where(User.username == 'Alice')
    # Peewee автоматически создаст условие ON Tweet.user_id == User.id
    ```
    
- **Явное условие (параметр `on`):** Необходимо, когда:
    
    - Peewee не может вывести условие (например, нет `ForeignKeyField` или их несколько).
    - Требуется объединение по неключевым полям.
    - Выполняется самообъединение (self-join) с использованием псевдонимов моделей.10
    
    Python
    
    ```
    # Объединение по произвольным полям
    query = Order.select().join(LegacyUserData, on=(Order.customer_email == LegacyUserData.email))
    ```
    
    При наличии нескольких внешних ключей от одной модели к другой, явное указание `on` становится обязательным, чтобы Peewee знал, по какой именно связи выполнять объединение.10

### Выборка данных из объединенных моделей

При выполнении JOIN-запроса можно выбирать поля из любой из объединенных моделей, передавая их в метод `select()`.10

Python

```
query = Tweet.select(Tweet.content, Tweet.created_date, User.username).join(User)
for item in query:
    print(f"Tweet: '{item.content}' by {item.user.username} on {item.created_date}")
```

В этом примере, несмотря на то что `User.username` было выбрано явно, Peewee также "собирает" объект `User` и помещает его в атрибут `tweet.user` (если `Tweet.user` это `ForeignKeyField` к `User`). Таким образом, доступ к `item.user.username` возможен. Если бы мы хотели, чтобы `username` был прямым атрибутом объекта `item`, можно было бы использовать `.objects()` или псевдонимы полей.

### Объединение нескольких таблиц

Peewee поддерживает "контекст объединения". Это означает, что последующий вызов `.join()` будет пытаться объединиться с последней присоединенной моделью или с основной моделью запроса, если это первый `join`.10

- **Последовательные объединения:**
    
    Python
    
    ```
    # A -> B -> C
    query = A.select().join(B).join(C)
    ```
    
- **Изменение контекста объединения:**
    - `switch(Model)`: Устанавливает указанную модель как текущий контекст для следующего `join()`. Это полезно, когда граф объединений нелинейный.10
        
        Python
        
        ```
        # Favorite -> User (для информации о пользователе, поставившем лайк)
        # Favorite -> Tweet (для информации о лайкнутом твите)
        query = (Favorite
                .select(User.username, Tweet.content)
                .join(User)  # Favorite.user_id == User.id
                .switch(Favorite) # Возвращаем контекст к Favorite
                .join(Tweet)) # Favorite.tweet_id == Tweet.id
        ```
        
    - `join_from(SourceModel, TargetModel,...)`: Явно указывает исходную и целевую модель для объединения, что может быть более читаемо, чем `switch()` в некоторых случаях.10

### Самообъединения (Self-joins)

Самообъединение — это объединение таблицы с самой собой. Это часто используется для иерархических данных (например, категории и подкатегории, сотрудники и их менеджеры). Для выполнения самообъединения в Peewee необходимо создать псевдоним (alias) для модели.10

Python

```
class Employee(BaseModel):
    name = CharField()
    manager = ForeignKeyField('self', null=True, backref='subordinates')

Manager = Employee.alias() # Создаем псевдоним для таблицы Employee

# Выбрать всех сотрудников и имена их менеджеров
query = (Employee
        .select(Employee.name.alias('employee_name'), Manager.name.alias('manager_name'))
        .join(Manager, JOIN.LEFT_OUTER, on=(Employee.manager == Manager.id)))

for emp in query:
    print(f"Employee: {emp.employee_name}, Manager: {emp.manager_name or 'N/A'}")
```

### Проблема N+1 запросов и ее решение

**Проблема N+1 запросов** — это распространенная проблема производительности при работе с ORM. Она возникает, когда сначала выполняется один запрос для получения коллекции родительских объектов (1 запрос), а затем для каждого родительского объекта выполняется один или несколько дополнительных запросов для загрузки связанных с ним дочерних объектов (N запросов).2 Чаще всего это происходит при итерации по результатам и доступе к атрибутам, представляющим внешние ключи или обратные ссылки, без предварительной загрузки этих связанных данных.

**Решения в Peewee:**

1. Использование join() для загрузки связанных данных:
    
    Если вам нужны данные из связанных таблиц для фильтрации или для немедленного использования вместе с данными основной модели, join() является подходящим решением. Когда вы выбираете поля из нескольких моделей с использованием join(), Peewee попытается построить граф объектов, так что доступ к связанным данным не вызовет дополнительных запросов.2
    
    Python
    
    ```
    # Пример, где N+1 МОЖЕТ возникнуть без правильного JOIN
    # pets = Pet.select()
    # for pet in pets:
    #     print(pet.name, pet.owner.name) # Здесь pet.owner.name вызовет доп. запрос для каждого питомца
    
    # Решение с JOIN
    query = Pet.select(Pet, Person).join(Person).where(Pet.animal_type == 'cat')
    for pet in query:
        # Дополнительного запроса для pet.owner.name не будет,
        # так как данные Person были загружены вместе с Pet
        print(pet.name, pet.owner.name)
    ```
    
    Этот подход эффективен для отношений "один-к-одному" и "многие-к-одному".
    
2. Использование prefetch() для эффективной загрузки коллекций:
    
    Для отношений "один-ко-многим" или "многие-ко-многим", когда для каждого объекта из основного запроса нужно загрузить коллекцию связанных объектов (например, все посты пользователя, все теги статьи), prefetch() является предпочтительным методом. prefetch() выполняет минимальное количество дополнительных запросов (обычно один на каждое связанное отношение) для загрузки всех необходимых связанных объектов сразу, а затем связывает их с родительскими объектами в Python.2
    
    Python
    
    ```
    # Пример N+1:
    # for person in Person.select():
    #     print(person.name)
    #     for pet in person.pets: # person.pets (backref) вызовет запрос для каждого person
    #         print(' *', pet.name)
    
    # Решение с prefetch()
    # Предположим, Pet.owner = ForeignKeyField(Person, backref='pets')
    query = Person.select().order_by(Person.name).prefetch(Pet)
    # Peewee выполнит 2 запроса: один для Person, один для всех Pet, связанных с выбранными Person.
    for person in query:
        print(person.name)
        for pet in person.pets: # Теперь доступ к person.pets не вызывает доп. запросов
            print(' *', pet.name)
    ```
    
    `prefetch()` принимает один или несколько запросов для предварительной выборки. Это мощный инструмент для оптимизации, который не изменяет структуру основного запроса, а лишь эффективно догружает связанные данные.
    

Понимание и активное предотвращение проблемы N+1 запросов является ключевым аспектом написания производительного кода с использованием любой ORM. Peewee предоставляет `join()` и `prefetch()` как основные инструменты для решения этой проблемы. `join()` изменяет основной SQL-запрос, чтобы включить данные из других таблиц, в то время как `prefetch()` выполняет отдельные, оптимизированные запросы для загрузки связанных коллекций после выполнения основного запроса.

## 7. Продвинутые Запросы

Помимо базовой фильтрации и объединений, Peewee предлагает возможности для более сложных запросов, включая сортировку, пагинацию, агрегацию и использование SQL-функций.

### Сортировка результатов: `.order_by(*fields)`

Метод `.order_by()` используется для сортировки записей в результатах запроса.13

- **Порядок сортировки:**
    
    - По возрастанию (ASC): `Model.field` или `Model.field.asc()`. Это порядок по умолчанию.
    - По убыванию (DESC): `Model.field.desc()` или с использованием префиксного минуса `-Model.field`.17
    
    Python
    
    ```
    # Сортировка пользователей по имени пользователя по возрастанию
    users_asc = User.select().order_by(User.username)
    # Сортировка твитов по дате создания по убыванию (сначала новые)
    latest_tweets = Tweet.select().order_by(Tweet.created_date.desc())
    # или
    latest_tweets_alt = Tweet.select().order_by(-Tweet.created_date)
    ```
    
- **Сортировка по нескольким полям:** Можно указать несколько полей для сортировки. Записи будут отсортированы по первому полю, затем по второму полю внутри групп с одинаковыми значениями первого поля, и так далее.
    
    Python
    
    ```
    # Сортировка пользователей по фамилии, затем по имени
    users_sorted = User.select().order_by(User.last_name, User.first_name)
    ```
    
- **Сортировка по результату SQL-функции или выражению:** Можно сортировать по вычисляемым значениям или псевдонимам, используя `fn()` или `SQL()`.13
    
    Python
    
    ```
    from peewee import fn, SQL
    # Сортировка пользователей по длине имени пользователя (пример)
    users_by_username_length = User.select().order_by(fn.Length(User.username).desc())
    
    # Сортировка по псевдониму (если псевдоним был задан в select)
    query = (User
            .select(User.username, fn.COUNT(Tweet.id).alias('num_tweets'))
            .join(Tweet, JOIN.LEFT_OUTER)
            .group_by(User.username)
            .order_by(SQL('num_tweets').desc())) # или order_by(fn.COUNT(Tweet.id).desc())
    ```
    

### Пагинация

Пагинация — это процесс разделения большого набора результатов на отдельные "страницы". Peewee предоставляет несколько способов для ее реализации:

- **`.paginate(page_number, items_per_page)`**: Наиболее удобный высокоуровневый метод. `page_number` — номер страницы (начинается с 1), `items_per_page` — количество записей на странице.13
    
    Python
    
    ```
    # Получить вторую страницу твитов, по 10 твитов на странице, отсортированных по ID
    page_2_tweets = Tweet.select().order_by(Tweet.id).paginate(2, 10)
    ```
    
- **`.limit(count)`**: Ограничивает количество возвращаемых записей.18
- **`.offset(count)`**: Пропускает указанное количество записей перед началом выборки.26 Методы `limit()` и `offset()` являются низкоуровневыми строительными блоками для пагинации. `paginate(page, count)` фактически вычисляет `limit(count).offset((page - 1) * count)`.
    
    Python
    
    ```
    page_num = 3
    items_per_page = 20
    # Эквивалентно.paginate(page_num, items_per_page)
    paged_results = (Product.select()
                    .order_by(Product.name)
                    .limit(items_per_page)
                    .offset((page_num - 1) * items_per_page))
    ```
    

Использование `paginate` проще для стандартных сценариев пагинации, в то время как `limit` и `offset` предоставляют больше гибкости для нестандартных случаев.

### Агрегатные функции (`fn.COUNT`, `fn.SUM`, `fn.AVG`, `fn.MAX`, `fn.MIN`)

Агрегатные функции выполняют вычисления на наборе строк и возвращают одно сводное значение. В Peewee они доступны через объект `fn`.13

- `fn.COUNT(Model.id_field_or_asterisk)`: Подсчитывает количество строк. Если передано поле, подсчитывает не-NULL значения этого поля. `fn.COUNT(SQL('*'))` или `fn.COUNT(1)` также используются для подсчета всех строк.
    
    Python
    
    ```
    total_books = Book.select(fn.COUNT(Book.id)).scalar(db) # Требует db для.scalar()
    # или проще:
    total_books_alt = Book.select().count() # Не требует db, т.к. count() - метод запроса
    active_users_count = User.select().where(User.is_active == True).count()
    ```
    
- `fn.SUM(Model.numeric_field)`: Вычисляет сумму значений в числовом поле.
    
    Python
    
    ```
    total_revenue = OrderItem.select(fn.SUM(OrderItem.price * OrderItem.quantity)).scalar(db)
    ```
    
- `fn.AVG(Model.numeric_field)`: Вычисляет среднее значение.
    
    Python
    
    ```
    average_rating = Review.select(fn.AVG(Review.rating)).scalar(db)
    ```
    
- `fn.MIN(Model.field)`: Находит минимальное значение.
    
    Python
    
    ```
    cheapest_product_price = Product.select(fn.MIN(Product.price)).scalar(db)
    ```
    
- `fn.MAX(Model.field)`: Находит максимальное значение.
    
    Python
    
    ```
    latest_order_date = Order.select(fn.MAX(Order.order_date)).scalar(db)
    ```
    

Для получения результата агрегатной функции, которая возвращает одно значение, удобно использовать метод `.scalar(db)`.13

### Группировка: `.group_by(*fields)`

Метод `.group_by()` используется в сочетании с агрегатными функциями для группировки строк, имеющих одинаковые значения в указанных столбцах, в одну сводную строку.2

Python

```
# Подсчитать количество книг каждого автора
author_book_counts = (Book
                     .select(Book.author, fn.COUNT(Book.id).alias('num_books'))
                     .group_by(Book.author)
                     .order_by(SQL('num_books').desc()))

for item in author_book_counts:
    print(f"Author: {item.author}, Books: {item.num_books}")
```

### Фильтрация групп: `.having(*expressions)`

Метод `.having()` применяется после `.group_by()` и используется для фильтрации сгруппированных результатов на основе условия, которое обычно включает агрегатную функцию.13 Это аналог SQL `HAVING`.

Python

```
# Найти авторов, у которых более 5 книг
prolific_authors = (Book
                   .select(Book.author, fn.COUNT(Book.id).alias('num_books'))
                   .group_by(Book.author)
                   .having(fn.COUNT(Book.id) > 5) # или.having(SQL('num_books') > 5)
                   .order_by(SQL('num_books').desc()))
```

### Выборка конкретных полей и выражений с использованием псевдонимов (`.alias()`)

Метод .select() позволяет точно указать, какие поля или вычисляемые выражения должны быть включены в результат запроса.13

Метод .alias('name') присваивает псевдоним (alias) выбранному полю или выражению. Этот псевдоним затем можно использовать:

- Как ключ при доступе к данным, если результаты возвращаются в виде словарей (`.dicts()`).
- Как атрибут, если результаты возвращаются как экземпляры моделей (Peewee попытается присвоить его экземпляру).
- В других частях запроса, например, в `.order_by(SQL('alias_name'))` или `.having(SQL('alias_name') > value)`.2

Python

```
query = (User
        .select(
             User.username,
             User.email,
             fn.COUNT(Tweet.id).alias('total_tweets') # Псевдоним для количества твитов
         )
        .join(Tweet, JOIN.LEFT_OUTER, on=(Tweet.user == User.id))
        .group_by(User.username, User.email)
        .order_by(SQL('total_tweets').desc()))

for user_stat in query.dicts(): # Результат в виде словарей
    print(f"User: {user_stat['username']}, Email: {user_stat['email']}, Tweets: {user_stat['total_tweets']}")
```

### Использование SQL-функций с `fn()`

Объект `fn` в Peewee является "магическим" помощником, который позволяет вызывать практически любую SQL-функцию, поддерживаемую вашей СУБД, даже если для нее нет явного метода в Peewee.2

- Примеры:
    - `fn.Lower(User.username)`: Преобразует имя пользователя в нижний регистр.
    - `fn.Substr(User.username, 1, 3)`: Возвращает подстроку (первые 3 символа имени).
    - `fn.Date_part('year', Model.created_date)` (для PostgreSQL): Извлекает год из даты.
    - `fn.Rand()` или `fn.Random()` (зависит от СУБД): Генерирует случайное число. 17
- Вызовы `fn()` можно вкладывать друг в друга:
    
    Python
    
    ```
    # Получить первую букву имени пользователя в нижнем регистре
    first_letter_lower = fn.Lower(fn.Substr(User.username, 1, 1))
    query = User.select(User.username, first_letter_lower.alias('initial'))
    ```
    
    32

Использование `fn()` обеспечивает огромную гибкость, позволяя задействовать специфичные для СУБД функции без необходимости писать "сырые" SQL-запросы для простых вызовов функций. Это особенно полезно, когда стандартных возможностей ORM недостаточно для выражения сложной логики или использования оптимизированных функций базы данных.

## 8. Работа с Peewee в Функциях

При структурировании кода и вынесении логики работы с базой данных в отдельные функции важно правильно управлять соединениями и транзакциями.

### Управление соединением с БД

- **`db.connect(reuse_if_open=True)`**: Этот метод устанавливает соединение с базой данных. Параметр `reuse_if_open=True` предотвращает возникновение ошибки `peewee.OperationalError`, если попытаться открыть уже открытое соединение; вместо этого он просто использует существующее.1
    
- **`db.close()`**: Закрывает соединение с базой данных. Важно закрывать соединения после завершения работы с ними, особенно в долгоживущих приложениях или при использовании пулов соединений, чтобы освободить ресурсы.1
    
- **`db.is_closed()`**: Возвращает `True`, если соединение закрыто, и `False` в противном случае. Может использоваться для проверки состояния соединения перед попыткой его открыть или закрыть.36
    
- Менеджер контекста with db: (или db.connection_context()):
    
    Это предпочтительный способ управления соединениями в большинстве случаев. Он гарантирует, что соединение будет открыто перед выполнением блока кода и автоматически закрыто после его завершения, даже если внутри блока возникнет исключение [36 (для пула соединений), 37].
    
    Python
    
    ```
    # db - это ваш экземпляр SqliteDatabase (или другого типа Database)
    with db: # db.connect() вызывается неявно при входе в блок
        #... здесь выполняются операции с базой данных...
        user = User.create(username='example_user')
    # db.close() вызывается неявно при выходе из блока
    ```
    
    Использование менеджера контекста значительно упрощает код и делает его более безопасным, так как автоматически обрабатывает открытие и закрытие соединений, снижая риск утечек ресурсов или ошибок, связанных с состоянием соединения.
    

### Управление транзакциями: `db.atomic()`

Транзакции обеспечивают атомарность операций с базой данных: либо все изменения в рамках транзакции успешно применяются (COMMIT), либо, в случае ошибки, все изменения полностью отменяются (ROLLBACK), возвращая базу данных в состояние до начала транзакции. Это критически важно для поддержания целостности данных.

Peewee предоставляет метод `db.atomic()` для управления транзакциями.13

- **`db.atomic()` как менеджер контекста (рекомендуемый способ):**
    
    Python
    
    ```
    from peewee import IntegrityError
    
    with db.atomic() as transaction: # Начало транзакции
        try:
            user = User.create(username='NewUser', email='new@example.com')
            Profile.create(user=user, bio='Initial bio.')
            # Если обе операции успешны, транзакция будет автоматически закоммичена
            # при выходе из блока with. Явный transaction.commit() не требуется.
        except IntegrityError as e:
            # Если возникает ошибка (например, дублирующийся username),
            # транзакция будет автоматически отменена при выходе из блока with
            # из-за необработанного исключения.
            # Можно также явно откатить:
            # transaction.rollback()
            print(f"Failed to create user and profile: {e}")
            # Важно: если вы здесь обработали исключение и не хотите, чтобы
            # Peewee автоматически откатил транзакцию, нужно либо явно
            # закоммитить (если это осмысленно), либо позволить исключению
            # выйти из блока with, чтобы Peewee выполнил откат.
            # В данном примере, если IntegrityError произошел, мы просто логируем
            # и позволяем Peewee откатить транзакцию.
            raise # Перевыбрасываем исключение, чтобы Peewee откатил транзакцию
    ```
    
    Если внутри блока `with db.atomic()` не возникает исключений, транзакция автоматически коммитится. Если возникает исключение, которое не обрабатывается внутри блока (или перевыбрасывается), транзакция автоматически откатывается.
    
- db.atomic() как декоратор:
    
    Можно использовать db.atomic() для декорирования функций. В этом случае вся функция будет выполняться в рамках одной транзакции.
    
    Python
    
    ```
    @db.atomic()
    def create_user_with_profile(username, email, bio_text):
        user = User.create(username=username, email=email)
        Profile.create(user=user, bio=bio_text)
        return user
    
    # Вызов функции приведет к выполнению операций в транзакции
    # new_user = create_user_with_profile('decorated_user', 'decorated@ex.com', 'Bio via decorator')
    ```
    
- Вложенные транзакции и точки сохранения (savepoints):
    
    db.atomic() элегантно обрабатывает вложенность. Если один блок db.atomic() вызывается внутри другого, внешний блок создает настоящую транзакцию, а все внутренние блоки db.atomic() создают точки сохранения (savepoints).37
    
    - Если внутренний блок (savepoint) завершается с ошибкой и откатывается, изменения откатываются только до этой точки сохранения. Успешные изменения во внешнем блоке (до этого savepoint'а) остаются.
    - Если внешний блок (транзакция) откатывается, то все изменения, включая те, что были успешно закоммичены во внутренних savepoint'ах, будут отменены.
    
    Python
    
    ```
    with db.atomic() as outer_txn: # Начинается транзакция
        User.create(username='user_A')
        try:
            with db.atomic() as inner_txn_1: # Начинается savepoint
                User.create(username='user_B')
                # Предположим, здесь возникает ошибка, и inner_txn_1 откатывается
                raise ValueError("Something went wrong with user_B")
        except ValueError:
            print("Inner transaction 1 for user_B rolled back.")
            # user_B не будет создан
    
        with db.atomic() as inner_txn_2: # Начинается другой savepoint
            User.create(username='user_C')
            # inner_txn_2 успешно завершается, изменения для user_C "закоммичены" на уровне savepoint
    
    # Если внешний outer_txn успешно завершается, то user_A и user_C будут сохранены.
    # Если бы в outer_txn после inner_txn_2 возникла ошибка, то все (A и C) было бы отменено.
    ```
    
- **`db.transaction()`:** Это более низкоуровневый API для работы с транзакциями. Основное отличие от `db.atomic()` в том, что если вы явно вызываете `transaction.commit()` или `transaction.rollback()` внутри блока `db.transaction()`, то _новая_ транзакция начинается автоматически. Однако, вложенные вызовы `db.transaction()` не создают savepoints; только самый внешний вызов управляет реальной транзакцией. Из-за этого потенциально менее предсказуемого поведения для большинства случаев, особенно с вложенностью, рекомендуется использовать `db.atomic()`.37
    

Использование `db.atomic()` является фундаментальным для обеспечения целостности данных при выполнении нескольких связанных операций. Это гарантирует, что либо все операции будут выполнены успешно, либо ни одна из них не повлияет на состояние базы данных.

### Рекомендации по написанию функций

При написании функций, взаимодействующих с базой данных через Peewee:

1. **Передача зависимостей:**
    
    - **Глобальный `db`:** В небольших приложениях или скриптах часто используется глобальный экземпляр `db`, определенный в одном модуле (например, `database.py`) и импортируемый в другие модули по мере необходимости. Это простой и распространенный подход в Peewee.1 Модели обычно уже связаны с этим глобальным `db` через их `BaseModel`.
    - **Явная передача `db`:** Если вы пишете библиотеку или модуль, который должен быть более гибким и тестируемым, или если ваше приложение может работать с несколькими базами данных, передача экземпляра `db` в функции может быть лучшим решением.
    - **Модели как параметры:** Функции, оперирующие конкретными моделями, естественно, будут использовать эти модели. Если модели не привязаны к глобальному `db`, то может потребоваться и передача `db`.
2. **Логика внутри функции:**
    
    - **Атомарность:** Если функция выполняет несколько операций записи, обновления или удаления, которые должны быть выполнены как единое целое (либо все, либо ничего), оберните эту логику в `with db.atomic():`.
    - **Управление соединением:** Управление соединениями (`db.connect()`, `db.close()`) обычно лучше выносить на более высокий уровень приложения (например, при запуске/остановке веб-сервера, в middleware для веб-запросов). Если функция является самодостаточной утилитой или скриптом, она может управлять соединением сама, предпочтительно используя `with db:`.
3. **Пример структуры функции:**
    
    Python
    
    ```
    # Предполагается, что db и модели (User, Profile) импортированы
    # или db передается как аргумент, а модели используют этот db.
    
    def create_user_and_profile_atomic(username, email, profile_info, database_instance):
        """
        Создает пользователя и его профиль в рамках одной транзакции.
        Принимает экземпляр базы данных для большей гибкости.
        """
        with database_instance.atomic(): # Используем переданный экземпляр db
            user = User.create(username=username, email=email)
            # Привязываем профиль к пользователю
            profile_data = {'user': user, **profile_info}
            Profile.create(**profile_data)
            return user
    
    # Пример использования с глобальным db:
    # def create_user_and_profile_global_db(username, email, profile_info):
    #     with db.atomic(): # Используем глобальный db
    #         user = User.create(username=username, email=email)
    #         profile_data = {'user': user, **profile_info}
    #         Profile.create(**profile_data)
    #         return user
    
    # Управление соединением на более высоком уровне:
    # db.connect(reuse_if_open=True)
    # try:
    #     new_user = create_user_and_profile_atomic('test_user', 'test@example.com', {'bio': 'My bio'}, db)
    #     # или new_user = create_user_and_profile_global_db(...)
    #     print(f"Создан пользователь: {new_user.username}")
    # except Exception as e:
    #     print(f"Ошибка при создании пользователя: {e}")
    # finally:
    #     db.close()
    ```
    

Инкапсуляция логики работы с БД в функции улучшает структуру кода, его тестируемость и возможность повторного использования. Применение `db.atomic()` внутри таких функций обеспечивает их надежность и предсказуемость поведения в случае ошибок.

## 9. Особенности Peewee для Пользователей SQLite

SQLite является популярным выбором для многих проектов благодаря своей простоте и отсутствию необходимости в отдельном сервере. Peewee отлично работает с SQLite, но есть несколько особенностей, которые стоит учитывать.

- **Простота настройки:** Как уже упоминалось, для SQLite достаточно указать имя файла базы данных при создании экземпляра `SqliteDatabase`. Файл будет создан автоматически, если он не существует. Это делает SQLite идеальным для быстрого старта, разработки и небольших приложений.
    
- Внешние ключи в SQLite (foreign_keys pragma):
    
    По умолчанию в некоторых версиях SQLite механизм обеспечения ссылочной целостности через внешние ключи может быть отключен. Хотя Peewee будет создавать определения FOREIGN KEY в DDL, SQLite может не применять ограничения (например, ON DELETE CASCADE может не сработать) без явного включения этой функциональности.
    
    Настоятельно рекомендуется включать поддержку внешних ключей при инициализации SqliteDatabase с помощью прагмы foreign_keys=1.10
    
    Python
    
    ```
    db = SqliteDatabase('my_application.db', pragmas={'foreign_keys': 1})
    ```
    
    Это обеспечит ожидаемое поведение ограничений внешних ключей, таких как каскадное удаление или запрет на удаление родительской записи при наличии связанных дочерних записей. Не включение этой прагмы является частым источником путаницы для пользователей, ожидающих стандартного SQL-поведения от внешних ключей.
    
- **Типы данных:** SQLite использует динамическую систему типизации, но столбцы все же имеют "предпочтительный" тип (type affinity). Peewee сопоставляет свои типы полей с соответствующими типами SQLite (например, `BooleanField` обычно сопоставляется с `INTEGER`, храня 0 или 1; `DateField` с `TEXT` или `DATE`). Это важно помнить при прямом просмотре или редактировании файла базы данных SQLite сторонними инструментами. (См. Таблицу 1 для сопоставлений).
    
- Расширения Playhouse для SQLite:
    
    Модуль playhouse в Peewee содержит множество полезных расширений, некоторые из которых специфичны или особенно полезны для SQLite, значительно расширяя его стандартные возможности 45:
    
    - **`playhouse.sqlite_ext`**: Этот модуль является основой для многих расширенных функций SQLite. Он включает `SqliteExtDatabase`, который поддерживает такие вещи, как:
        - **JSON1**: Поддержка функций для работы с JSON-данными (требует SQLite, скомпилированного с расширением JSON1).
        - **FTS5 (Full-Text Search 5)**: Мощный полнотекстовый поиск (требует SQLite, скомпилированного с FTS5).
        - **R-Tree**: Поддержка пространственных индексов для геоданных.
        - Другие специфичные для SQLite функции и виртуальные таблицы. (Хотя детальное описание этих расширений выходит за рамки базового руководства, важно знать о их существовании для более сложных задач).
    - **`playhouse.sqlite_udf`**: Позволяет регистрировать пользовательские SQL-функции (скалярные, агрегатные и табличные) на Python, которые затем можно вызывать в запросах Peewee. Примеры включают функции для работы с файлами, сетью, строками, математические функции и т.д. (например, `hostname()`, `gzip()`, `median()`, `damerau_levenshtein_dist()`).45
    - **`playhouse.sqliteq`**: Предоставляет `SqliteQueueDatabase`, которая сериализует операции записи в SQLite из нескольких потоков через одну очередь и один рабочий поток. Это помогает избежать ошибок `database is locked` при конкурентной записи в многопоточных приложениях.45
    - **`playhouse.sqlcipher_ext`**: Включает `SqlCipherDatabase` для работы с зашифрованными базами данных SQLite с использованием SQLCipher.45 Упоминание Playhouse показывает, что связка Peewee и SQLite способна на большее, чем просто базовые CRUD-операции, и может быть расширена для сложных сценариев, таких как полнотекстовый поиск или работа с JSON-данными.
- Выполнение "сырых" SQL-запросов:
    
    Хотя основная идея ORM — абстрагироваться от написания SQL, иногда возникает необходимость выполнить специфичный для СУБД или очень сложный запрос, который трудно или невозможно выразить через API ORM. Peewee позволяет это сделать с помощью метода db.execute_sql().13
    
    Python
    
    ```
    # db - ваш экземпляр Database
    cursor = db.execute_sql(
        "SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';"
    )
    for row in cursor:
        print(f"Table name: {row}")
    
    # Запрос с параметрами (для безопасности используйте плейсхолдеры)
    user_id = 1
    cursor = db.execute_sql(
        "UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id =?;",
        (user_id,) # Параметры передаются как кортеж
    )
    updated_rows = cursor.rowcount # Для UPDATE/DELETE может вернуть количество затронутых строк
    ```
    
    `db.execute_sql()` возвращает стандартный DB-API курсор. Это дает полный контроль, но также требует большей осторожности, особенно в части предотвращения SQL-инъекций при использовании пользовательского ввода (всегда используйте параметризованные запросы).
    
- **Ограничения SQLite:**
    
    - **Лимит на количество связанных переменных (parameters):** SQLite имеет ограничение на максимальное количество параметров, которые можно использовать в одном SQL-запросе. До версии SQLite 3.32.0 (22 мая 2020 г.) этот лимит обычно составлял 999. В более новых версиях он был увеличен до 32766. Это может повлиять на массовые операции, такие как `Model.insert_many()`, если вы пытаетесь вставить очень большое количество строк или строк с большим количеством полей за один вызов. Peewee предоставляет утилиту `chunked()` для разбиения больших наборов данных на более мелкие части.13
    - **Конкурентный доступ:** Стандартный SQLite (без `SqliteQueueDatabase` или WAL-режима, настроенного определенным образом) имеет ограничения по конкурентной записи, что может приводить к ошибкам `database is locked` в многопоточных или многопроцессных приложениях.

Знание этих специфичных для SQLite моментов поможет более эффективно использовать Peewee с этой популярной встраиваемой базой данных.

## 10. Заключение

Peewee ORM представляет собой мощный, но в то же время простой и интуитивно понятный инструмент для работы с базами данных в Python. Его минималистичный API, поддержка основных СУБД (SQLite, PostgreSQL, MySQL) и гибкие возможности построения запросов делают его привлекательным выбором как для начинающих, так и для опытных разработчиков.

В данном руководстве были рассмотрены ключевые аспекты работы с Peewee: от первоначальной настройки и определения моделей до выполнения CRUD-операций, построения сложных запросов с объединениями, агрегацией и сортировкой. Особое внимание было уделено практическим моментам, таким как управление соединениями и транзакциями в функциях, а также специфике использования Peewee с SQLite, включая решение проблемы N+1 запросов и использование расширений из Playhouse.

Peewee успешно балансирует между простотой использования и мощностью предоставляемых возможностей. Он позволяет быстро начать работу, но при этом не ограничивает разработчика в реализации сложной логики взаимодействия с базой данных. Для пользователей, знакомых с SQL, переход на Peewee будет достаточно плавным благодаря логичной структуре его API и возможности выполнять "сырые" SQL-запросы при необходимости.

Рекомендуется продолжить изучение официальной документации Peewee, так как она содержит еще больше примеров, описаний продвинутых функций и расширений. Экспериментирование с различными типами запросов и сценариями использования поможет глубже понять возможности этой замечательной ORM и эффективно применять ее в своих проектах.